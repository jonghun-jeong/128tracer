volatile int L_motor[4]={0xc0,0x60,0x30,0x90};volatile int L_t=0;volatile char calib_flg=0;volatile int R_motor[4]={0x09,0x03,0x06,0x0c};volatile int R_t=0;volatile int led_value[8];volatile int j=0;volatile unsigned char led_average[8];volatile unsigned char led_max[8]={0,0,0,0,0,0,0,0};volatile int led_val[8];volatile int all_sum=0;volatile float position_temp;volatile int position=400;volatile int Former_position=400;volatile unsigned int led_low[8]={255,255,255,255,255,255,255,255};volatile unsigned char calib_start=1;volatile int position_gap;volatile unsigned char direction=0;volatile unsigned int L_Motor_speed=0;volatile unsigned int R_Motor_speed=0;volatile unsigned int L_turn_mark;volatile unsigned int R_turn_mark;volatile unsigned int L_Motor_Control=400;volatile unsigned int R_Motor_Control=400;volatile unsigned int start=0;void calibration (void){           int i;     for(i=0;i<8;i++)     {       if(led_value[i]>led_max[i])       {         led_max[i]=led_value[i];       }         else if(led_value[i]<led_low[i])       {         led_low[i]=led_value[i];          }       led_average[i]=led_max[i]-led_low[i];     }   }
void sensing() {   int i;   all_sum = 0;  L_turn_mark=0;  R_turn_mark=0;   for(i=0;i<8;i++)   {     if(led_value[i]>led_max[i])     {       led_max[i]=led_value[i];     }       if(led_value[i]<led_low[i])     {       led_low[i]=led_value[i];        }     led_average[i]=led_max[i]-led_low[i];     led_val[i] = (unsigned char)(((led_value[i]-led_low[i])*100)/led_average[i]);     if(led_val[i]>100)led_val[i] = 100;     all_sum += led_val[i];    if(i<4)     L_turn_mark+=led_val[i];    else if(i>=4)     R_turn_mark+=led_val[i];
   }}void Catch_position(void){   char i;   position_temp = 0;  Former_position=position;     for(i=0; i<8;i++)    {       position_temp += (i+1)*led_val[i];      }    position_temp = position_temp/all_sum;     position = position_temp*100;    
   

}void Control_Motor(){/* if(position>=700&&position<800) {  R_Motor_Control=0;  L_Motor_Control=750; } else if(position>=650&&position<700) {  R_Motor_Control=5;  L_Motor_Control=700; } else if(position>=600) {  R_Motor_Control=10;  L_Motor_Control=750;   } if(position>=550) {  R_Motor_Control=50;  L_Motor_Control=700; }*/ if(position>=500) {  R_Motor_Control=120;  L_Motor_Control=650;  } else if(position>=460&&position<500) {  L_Motor_Control=position+60;  R_Motor_Control=710-position; } else if(position>=450&&position<460) {  L_Motor_Control=position+140;  R_Motor_Control=850-position; } else if(position>=440&&position<450) {  L_Motor_Control=position+110;  R_Motor_Control=900-position; } else if(position>=400&&position<440) {  L_Motor_Control=position-40;  R_Motor_Control=830-position; }  else if(position<400) {  L_Motor_Control=150;  R_Motor_Control=650; }/*  else if(position<350) {  L_Motor_Control=80;  R_Motor_Control=580; }  else if(position<300) {  L_Motor_Control=10;  R_Motor_Control=600; }   else if(position>=200&&position<250) {  L_Motor_Control=5;  R_Motor_Control=700; } else if(position>=100&&position<200) {  L_Motor_Control=0;  R_Motor_Control=750;   } */     }
void Set_MotorSpeed(){  if(L_Motor_speed>L_Motor_Control) {    while(L_Motor_speed>L_Motor_Control)  {   L_Motor_speed-=8;  } } else if(L_Motor_speed<L_Motor_Control) {    while(L_Motor_speed<L_Motor_Control)  {   L_Motor_speed+=8;  } } else if(R_Motor_speed>R_Motor_Control) {  while(R_Motor_speed>R_Motor_Control)  {   R_Motor_speed-=8;  } } else if(R_Motor_speed<R_Motor_Control) {  while(R_Motor_speed<R_Motor_Control)  {   R_Motor_speed+=8;  } }
}
void ADC_view(void){ /* int i;   for(i=0;i<8;i++)  {   while((UCSR0A&0x20)!=0x20);   UDR0=(((int)(led_val[i]/1000))+'0');      while((UCSR0A&0x20)!=0x20);   UDR0=((int)((led_val[i]/100)%10)+'0');      while((UCSR0A&0x20)!=0x20);   UDR0=(((int)((led_val[i]/10)%10))+'0');   while((UCSR0A&0x20)!=0x20);   UDR0=((led_val[i]%10)+'0');   while((UCSR0A&0x20)!=0x20);   UDR0=' ';  }while((UCSR0A&0x20)!=0x20);UDR0=0x0a;while((UCSR0A&0x20)!=0x20);UDR0=0x0b;*/
while((UCSR0A&0x20)!=0x20);UDR0=(((int)(position/1000))+'0');
while((UCSR0A&0x20)!=0x20);UDR0=((int)((position/100)%10)+'0');
while((UCSR0A&0x20)!=0x20);UDR0=(((int)((position/10)%10))+'0');while((UCSR0A&0x20)!=0x20);UDR0=((position%10)+'0');while((UCSR0A&0x20)!=0x20);UDR0=' ';}
void End_Mark(){  if((led_val[0]>60)&&(led_val[7]>60)&&(led_val[5]<40))  {   PORTB=0x01;   for(int i=0;i<10000;i++)   {    DDRA=0xff;    if((i%25)==0)    {     L_Motor_speed--;     R_Motor_speed--;    }       }   DDRA=0x00;  }}
ISR(TIMER1_COMPA_vect){ if(calib_flg) {  PORTA=(L_motor[L_t]+(PORTA&0x0f));  L_t++;  if(L_t==4)  {   L_t=0;  }  }    if(calib_flg)  {   if(start<5000)   {    start++;   }  }  if(start<1500)  {   OCR1A=Slow_TimeTable[L_Motor_speed];  }  else if(start>1500)  {   OCR1A=Motor_TimeTable[L_Motor_speed];  }  }
ISR(TIMER3_COMPA_vect){ if(calib_flg) {  PORTA=(R_motor[R_t]+(PORTA&0xf0));  R_t++;  if(R_t==4)  {   R_t=0;  }  }  if(start<1500)  {   OCR3A=Slow_TimeTable[R_Motor_speed];  }  else if(start>1500)  {   OCR3A=Motor_TimeTable[R_Motor_speed];  }}
SIGNAL(ADC_vect){  led_value[j++]=ADCH;   if(j==8)    j=0;   ADMUX=0x60+j;  ADCSRA=0xcf; }

int main(){ INIT_ADC(); INIT_IO(); INIT_TIMER(); INIT_USART(); sei();    while(calib_flg==0) {    while(calib_start)  {   if((PIND&0x03)==0x02)   {    calib_start=0;    PORTB=0x0c;   }  }    calibration();  
  if((PIND&0x03)==0x01)  {   calib_flg=1;   PORTB=0x00;  }   } while(1) {   if(start>19)  {   for(int i=0;i<10000;i++)   {    DDRA=0xff;    if((i%25)==0)    {     L_Motor_speed++;     R_Motor_speed++;    }      }   break;  } }    PORTB=0xff;  while(1) {   sensing();  Catch_position();  Control_Motor();  Set_MotorSpeed();  if(start>4900)  {   End_Mark();  } }  }
